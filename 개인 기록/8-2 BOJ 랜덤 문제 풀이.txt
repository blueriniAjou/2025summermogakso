2981 - 검문 (골드 4) (Sorting, Euclidean Algorithm)
https://github.com/blueriniAjou/2025summermogakso/blob/main/%EC%BD%94%EB%93%9C/2981.cpp
두 자연수를 어떤 자연수 M으로 나누었을 때의 나머지가 같다는 것은, 두 자연수의 차가 M의 배수라는 것과 동치입니다. 두 M의 배수의 차는 항상 M의 배수이므로, 모든 자연수 중 하나를 기준으로 두고 다른 모든 자연수와의 차의 공약수를 모두 구한 뒤 오름차순으로 정렬해 문제를 해결할 수 있습니다. 단, 1은 문제 조건에 따라 제외합니다.

14831 - 준표의 조약돌 (골드 4) (Two Pointer)
https://github.com/blueriniAjou/2025summermogakso/blob/main/%EC%BD%94%EB%93%9C/15831.cpp
구간에 대해 주어지는 조건의 특성상 두 포인터를 사용해 가장 긴 구간의 길이를 찾을 수 있습니다. 정당성 증명은 생략합니다.

5625 - 페스트리 (골드 3) (Prefix Sum, Difference Array Technique)
https://github.com/blueriniAjou/2025summermogakso/blob/main/%EC%BD%94%EB%93%9C/5625.cpp
페스트리마다 칼질을 했을 때 잘리는 구간이 정해져 있으므로, 모든 x좌표 및 y좌표에 대해 잘리는 페스트리의 개수를 미리 구해서 해결할 수 있습니다. 이를 빠르게 하기 위해 모든 페스트리의 구간에 대해 차분 배열을 구성한 뒤 해당 배열을 이용해 누적 합 배열을 구성했습니다.

34079 - 좋아하는 다이아몬드가 안경을 깜빡했다 (골드 1) (BFS, Traceback)
https://github.com/blueriniAjou/2025summermogakso/blob/main/%EC%BD%94%EB%93%9C/34079.cpp
1번 정점과 N번 정점을 잇는 모든 최단 경로에 포함되는 정점이 문제 조건을 만족하는 정점입니다. 
1번 정점과 N번 정점을 잇는 최단경로 상의 모든 정점만 고려합시다. BFS한 후 역추적하며 1번 정점과 N번 정점을 잇는 최단경로 상의 모든 정점을 찾을 수 있습니다. 
0 이상 N-1 이하의 모든 i에 대해, 어떤 1번 정점과 N번 정점을 잇는 최단 경로는 1번 정점과 최단거리가 i인 정점을 반드시 1개 지나야 합니다. 따라서 최단거리가 i인 정점이 유일하다면, 해당 정점은 문제 조건을 만족하는 정점입니다. 1번 정점과 최단거리가 i인 정점들의 집합 역시 역추적을 통해 구할 수 있습니다.
